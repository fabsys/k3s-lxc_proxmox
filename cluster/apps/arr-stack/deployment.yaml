---
# ==========================================
# JELLYFIN
# ==========================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jellyfin
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jellyfin
  template:
    metadata:
      labels:
        app: jellyfin
    spec:
      securityContext:
        fsGroup: 1000
      containers:
        - name: jellyfin
          image: docker.io/jellyfin/jellyfin:10.11.3
          ports:
            - containerPort: 8096
          volumeMounts:
            - name: config
              mountPath: /config
            # Montage unique pour l'accès global
            - name: all-media
              mountPath: /data
            - name: render-device
              mountPath: /dev/dri
      volumes:
        - name: config
          persistentVolumeClaim:
            claimName: jellyfin-pvc
        # Volume parent qui contient /movies, /shows et /downloads
        - name: all-media
          hostPath:
            path: /mnt/shared_data/movies
            type: Directory
        # Pour le render materiel
        - name: render-device
          hostPath:
            path: /dev/dri
            type: Directory

---
# ==========================================
# QBITTORRENT
# ==========================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: qbittorrent
spec:
  replicas: 1
  selector:
    matchLabels:
      app: qbittorrent
  template:
    metadata:
      labels:
        app: qbittorrent
    spec:
      securityContext:
        fsGroup: 1000
      
      initContainers:
        - name: configure-proxy-and-paths
          image: busybox
          command: ["sh", "-c"]
          args:
            - |
              echo "Configuration qBittorrent (Proxy & Paths)..."
              CONF_FILE="/config/qBittorrent/qBittorrent.conf"
              mkdir -p /config/qBittorrent
              
              if [ ! -f "$CONF_FILE" ]; then
                echo "[Preferences]" > "$CONF_FILE"
              fi

              # Nettoyage des anciennes configs pour éviter les doublons
              sed -i '/Connection\\Proxy/d' "$CONF_FILE"
              sed -i '/Session\\DefaultSavePath/d' "$CONF_FILE"
              
              # Injection Proxy SOCKS5 (Gluetun)
              echo "Connection\Proxy\IP=vpn-service.gluetun" >> "$CONF_FILE"
              echo "Connection\Proxy\Port=8888" >> "$CONF_FILE"
              echo "Connection\Proxy\Type=HTTP" >> "$CONF_FILE"
              echo "Connection\Proxy\LookupDNS=true" >> "$CONF_FILE"
              echo "Connection\Proxy\PeerOnly=false" >> "$CONF_FILE"
              echo "WebUI\LocalHostAuth=false" >> "$CONF_FILE"
              
              # Configuration du chemin de téléchargement unifié
              echo "Session\DefaultSavePath=/data/downloads" >> "$CONF_FILE"
              
              echo "Configuration terminée."
          volumeMounts:
            - name: config
              mountPath: /config

      containers:
        - name: qbittorrent
          image: lscr.io/linuxserver/qbittorrent:5.1.4
          env:
            - name: PUID
              value: "1000"
            - name: PGID
              value: "1000"
            - name: TZ
              value: "Europe/Paris"
            - name: WEBUI_PORT
              value: "8080"
          ports:
            - containerPort: 8080
          volumeMounts:
            - name: config
              mountPath: /config
            # Montage unique pour l'accès global
            - name: all-media
              mountPath: /data
      volumes:
        - name: config
          persistentVolumeClaim:
            claimName: qbittorrent-pvc
        - name: all-media
          hostPath:
            path: /mnt/shared_data/movies
            type: Directory

---
# ==========================================
# RADARR
# ==========================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: radarr
spec:
  replicas: 1
  selector:
    matchLabels:
      app: radarr
  template:
    metadata:
      labels:
        app: radarr
    spec:
      securityContext:
        fsGroup: 1000
      containers:
        - name: radarr
          image: lscr.io/linuxserver/radarr:6.0.4
          ports:
            - containerPort: 7878
          volumeMounts:
            - name: config
              mountPath: /config
            # Montage unique pour l'accès global
            - name: all-media
              mountPath: /data
      volumes:
        - name: config
          persistentVolumeClaim:
            claimName: radarr-pvc
        - name: all-media
          hostPath:
            path: /mnt/shared_data/movies
            type: Directory

---
# ==========================================
# SONARR
# ==========================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sonarr
spec:
  replicas: 1
  selector:
    matchLabels:
      app: sonarr
  template:
    metadata:
      labels:
        app: sonarr
    spec:
      securityContext:
        fsGroup: 1000
      containers:
        - name: sonarr
          image: lscr.io/linuxserver/sonarr:4.0.16
          ports:
            - containerPort: 8989
          volumeMounts:
            - name: config
              mountPath: /config
            # Montage unique pour l'accès global
            - name: all-media
              mountPath: /data
      volumes:
        - name: config
          persistentVolumeClaim:
            claimName: sonarr-pvc
        - name: all-media
          hostPath:
            path: /mnt/shared_data/movies
            type: Directory

---
# ==========================================
# PROWLARR
# ==========================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prowlarr
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prowlarr
  template:
    metadata:
      labels:
        app: prowlarr
    spec:
      securityContext:
        fsGroup: 1000
      
      initContainers:
        - name: download-custom-defs
          image: alpine:latest
          # On monte le même volume que Prowlarr pour y écrire le fichier
          volumeMounts:
            - name: config
              mountPath: /config
          command: ["/bin/sh", "-c"]
          args:
            - |
              echo "[Init] Vérification des définitions personnalisées..."
              
              # Installation de curl
              apk add --no-cache curl
              
              # Variables
              DEST="/config/Definitions/Custom"
              FILE="$DEST/ygg-api-magnet.yml"
              URL="https://gist.githubusercontent.com/Clemv95/8bfded23ef23ec78f6678896f42a2b60/raw/ygg-api-magnet.yml"
              
              mkdir -p "$DEST"
              
              if [ -f "$FILE" ]; then
                  echo "[Init] Le fichier existe déjà. Pas de téléchargement nécessaire."
                  
                  # Optionnel : On réapplique quand même les droits au cas où
                  chown 1000:1000 "$FILE"
                  chmod 644 "$FILE"
              else
                  echo "[Init] Fichier introuvable. Téléchargement en cours..."
                  
                  if curl -fsSL "$URL" -o "$FILE"; then
                      echo "[Init] Téléchargement réussi."
                      chown 1000:1000 "$FILE"
                      chmod 644 "$FILE"
                      echo "[Init] Permissions appliquées."
                  else
                      echo "[Init] ERREUR : Impossible de télécharger le fichier."
                      exit 1
                  fi
              fi
              echo "[Init] Terminé."

      containers:
        - name: prowlarr
          image: lscr.io/linuxserver/prowlarr:2.3.0.5236-ls132
          ports:
            - containerPort: 9696
          volumeMounts:
            - name: config
              mountPath: /config
      volumes:
        - name: config
          persistentVolumeClaim:
            claimName: prowlarr-pvc

---
# ==========================================
# JELLYSEERR
# ==========================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: jellyseerr
spec:
  replicas: 1
  selector:
    matchLabels:
      app: jellyseerr
  template:
    metadata:
      labels:
        app: jellyseerr
    spec:
      securityContext:
        fsGroup: 1000
      containers:
        - name: jellyseerr
          image: docker.io/fallenbagel/jellyseerr:2.7.3
          ports:
            - containerPort: 5055
          volumeMounts:
            - name: config
              mountPath: /app/config
      volumes:
        - name: config
          persistentVolumeClaim:
            claimName: jellyseerr-pvc

---
# ==========================================
# JOAL
# ==========================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: joal
  labels:
    app: joal
spec:
  replicas: 1
  selector:
    matchLabels:
      app: joal
  template:
    metadata:
      labels:
        app: joal
    spec:
      securityContext:
        fsGroup: 1000
      initContainers:
        - name: init-local-data
          image: ghcr.io/fabsys/joal:v1.0.2
          command: ["/bin/sh", "-c"]
          args:
            - |
              echo "[Init] Démarrage de la synchronisation des données..."
              
              # 1. Copie des fichiers d'origine de l'image (/data) vers le PVC (/pvc-data)
              # -r : Récursif
              # -n : No-clobber (ne remplace PAS les fichiers existants pour garder votre historique)
              # Cela va créer le dossier 'clients' s'il manque, mais garder vos stats si elles existent.
              cp -rn /data/* /pvc-data/
              
              # 2. Injection forcée de la configuration (depuis le ConfigMap)
              echo "[Init] Mise à jour de config.json..."
              cp /config-src/config.json /pvc-data/config.json
              
              # 3. Correction des permissions
              echo "[Init] Application des permissions..."
              chown -R 1000:1000 /pvc-data
              
              echo "[Init] Prêt à démarrer."
          volumeMounts:
            # On monte le PVC dans un dossier temporaire pour écrire dedans
            - name: joal-data
              mountPath: /pvc-data
            # On monte la source de config
            - name: joal-config
              mountPath: /config-src
            # IMPORTANT : On ne monte PAS /data ici, pour pouvoir lire les fichiers originaux de l'image

      containers:
        - name: joal
          image: ghcr.io/fabsys/joal:v1.0.2
          args:
            - "--joal-conf=/data"
            - "--spring.main.web-environment=true"
            - "--server.port=$(PORT)"
            - "--joal.ui.path.prefix=$(SECRET_OBFUSCATION_PATH)"
            - "--joal.ui.secret-token=$(SECRET_TOKEN)"
          ports:
            - containerPort: 8080
          env:
            - name: PORT
              value: "8080"
            - name: SECRET_OBFUSCATION_PATH
              value: "joal"
            - name: SECRET_TOKEN
              value: "token"
            - name: JAVA_TOOL_OPTIONS
              value: >-
                -Dhttp.proxyHost=vpn-service.gluetun
                -Dhttp.proxyPort=8888
          resources:
            requests:
              memory: "256Mi"
              cpu: "50m"
            limits:
              memory: "512Mi" # Java peut être gourmand, on le limite
          volumeMounts:
            # Ici, le PVC remplace /data (qui contient maintenant les fichiers copiés par l'init)
            - name: joal-data
              mountPath: /data
            # Le lien avec qBittorrent (HostPath)
            - name: torrent-import
              mountPath: /data/torrents
      volumes:
        - name: joal-config
          configMap:
            name: joal-config
        - name: joal-data
          persistentVolumeClaim:
            claimName: joal-config-pvc
        - name: torrent-import
          hostPath:
            # mkdir -p /mnt/shared_data/movies/joal-import
            # chmod 777 /mnt/shared_data/movies/joal-import
            path: /mnt/shared_data/movies/joal-import
            type: Directory